case ${OSTYPE} in
  darwin*)
    # alias ls='ls -hFG'
    alias ls='ls -hFG --color=auto'
    ;;
  linux*)
    alias ls='ls -hFG --color=auto'
    ;;
esac
alias ll='ls -l'
alias la='ls -A'
alias cp='cp -vi'
alias mv='mv -vi'
alias du='du -h'
# alias cat='more'
alias du='du -h'
# for charset
alias sort="LC_ALL='C' sort"
alias uniq="LC_ALL='C' uniq"
# alias s='screen -U'
alias zmv='noglob zmv'
alias sudo='sudo '
alias ta='tmux attach '
# alias mysql='mysql --local-infile=1'
alias javac='javac -J-Dfile.encoding=UTF-8'
alias java='java -Dfile.encoding=UTF-8'
alias scalac='scalac -J-Dfile.encoding=UTF-8'
alias scala='scala -Dfile.encoding=UTF-8'
# alias grep='grep -C 3 --color=always --line-number --with-filename'
alias o='git ls-files | peco | xargs -o vim'
alias g='cd $(ghq list -p | peco)'
alias reload='exec $SHELL -l'
alias mkdir='mkdir -p'
alias gg='git grep -I -C3 --break --heading'
# android
alias android_uninstallapp='adb shell pm list package | sed -e s/package:// | peco | xargs adb uninstall'
alias restart-adb='adb kill-server; adb start-server'
# alias adb='adbp'
# alias pidcat='pidcatp'
alias ip="ipconfig getifaddr `netstat -rn -f inet | awk '/^default/{print $6;exit}'`"
alias today='date +"%Y%m%d"'

function mas-install {
  mas search $1 | head -n 1 | cut -d' ' -f 1 | xargs -I{} mas install {}
}

# URL-encode
eurl() {
 # curl -sw '%{url_effective}' --data-urlencode "$1" -G '' | tr -d '?' | tr -d '/'
 # nkf automatically insert new line at 60char length
 echo $1 | nkf -WwMQ | tr = % | sed -e "s/%$//g" | tr -d '\n'
}

export LESS=' -R -N '
export GREP_OPTIONS="--color=always"
# export LESS=' -R '
# export LESSOPEN='| src-hilite-lesspipe.sh %s'


# --------------------------------------------------
#  original commands
# --------------------------------------------------
# remove files
# rm: just `mv` file(s) to ~/.Trash/<yyyymmdd>/
# rmf: original `rm`
function rmf() {
  help() {
    echo 'rmf help!'
    echo 'Usage: rmf [option] filename'
    return
  }
  for file in $*
  do
    case $file in
      -h|--help)
        help
        return
        ;;
      -rf|-fr)
        local option="-rf"
        ;;
      -r)
        local option="-r"
        ;;
      -f)
        local option="-f"
        ;;
      *)
        echo 'removed:' $file
        /bin/rm $option $file
    esac
  done
}

_rmfcmd() {
  _arguments \
    '(- *)'{-h,--help}'[show help]' \
    -r'[recursive]' \
    -f'[force]' \
    -rf'[recursive && force]' \
    '*: :_files'
}
compdef _rmfcmd rmf

function rm(){
  for file in $*
  do
    __rm_single_file $file
  done
}

function __rm_single_file(){
  local DATE=`date "+%y%m%d"`
  if ! [ -d ~/.Trash/$DATE/ ]
  then
    command /bin/mkdir -p ~/.Trash/$DATE/
  fi
  if ! [ $# -eq 1 ]
  then
    echo "__rm_single_file: 1 argument required but $# passed."
    exit
  fi
  if [ -e $1 ]
  then
    local BASENAME=`basename $1`
    local NAME=$BASENAME
    local COUNT=0
    while [ -e ~/.Trash/$DATE/$NAME ]
    do
      COUNT=$(($COUNT+1))
      NAME="$BASENAME.$COUNT"
    done
    command /bin/mv -v $1 ~/.Trash/$DATE/$NAME
  else
    echo "No such file or directory: $file"
  fi
}

# `cd` to cd and ls
function cdls() {
  \cd $1;
  ls;
}
alias cd=cdls

# counts of most used commands
function command-count() {
    local count
    if [ $# -ne 1 ]; then
      count=5
    else
      count=$1
    fi
    history-all | awk '{print $4}' | sort | uniq -c | sort -nr | head -n $count
}

# change directory to git-home
function git-home() {
  cd `git rev-parse --show-toplevel`
}

##########################################
# commands using peco
##########################################

# select from command-history
function peco-select-history() {
    local tac
    if which tac > /dev/null; then
        tac="tac"
    else
        tac="tail -r"
    fi
    BUFFER=$(history -n 1 | \
        eval $tac | \
        peco --query "$LBUFFER")
    CURSOR=$#BUFFER
    zle clear-screen
}
zle -N peco-select-history
bindkey '^r' peco-select-history

# select directory and `cd`
function peco-cdr(){
    local selected_dir=$(cdr -l | awk '{ print $2 }' | peco)
    if [ -n "$selected_dir" ]; then
        BUFFER="cd ${selected_dir}"
        zle accept-line
    fi
    zle clear-screen
}
zle -N peco-cdr
bindkey '^@' peco-cdr

# select file from `tree` and open it with vim
function peco-tree-vim(){
  local SELECTED_FILE=$(tree -N --charset=o -f | peco | sed -e "s/ ->.*\$//g" | tr -d '\||`| ' | xargs echo)
  if [ -n "$SELECTED_FILE" ]; then
    BUFFER="vim $SELECTED_FILE[3,-1]"
  fi
  zle accept-line
}
zle -N peco-tree-vim
bindkey "^v^t" peco-tree-vim

# select file from `tree`
function peco-tree-select(){
  local SELECTED_FILE=$(tree -N --charset=o -f | peco | sed -e "s/ ->.*\$//g" | tr -d '\||`| ' | xargs echo)
  if [ -n "$SELECTED_FILE" ]; then
    LBUFFER+="$SELECTED_FILE[3,-1]"
    CURSOR=$#LBUFFER
    zle reset-prompt
  fi
}
zle -N peco-tree-select
bindkey "^t" peco-tree-select

# select docker image hash
function peco_docker_image_id(){
    LBUFFER+=$(docker ps | tail -n +2 | peco | cut -d" " -f1)
    CURSOR=$#LBUFFER
    zle reset-prompt
}
zle -N peco_docker_image_id
bindkey "^gd" peco_docker_image_id

# grep files from current directory, select it and open in `less`
function peco_grep() {
  exec ack "$@" . | peco --exec 'awk -F : '"'"'{print "+" $2 " " $1}'"'"' | xargs less -N '
}
# zle -N peco_grep
# bindkey "^g^g" peco_grep

# select android device
function adb_locat_app() {
  APP_NAME=$1
  adb logcat | grep `adb shell ps | grep $1 | cut -c10-15`
}

##########################################
# Git commands using peco
##########################################

# select file to git add
function peco-select-git-add() {
    local SELECTED_FILE_TO_ADD="$(git status --short | \
                                  peco --query "$LBUFFER" | \
                                  awk -F ' ' '{print $NF}')"
    if [ -n "$SELECTED_FILE_TO_ADD" ]; then
      BUFFER="git add $(echo "$SELECTED_FILE_TO_ADD" | tr '\n' ' ')"
      CURSOR=$#BUFFER
    fi
    zle accept-line
    # zle clear-screen
}
zle -N peco-select-git-add
bindkey "^g^a" peco-select-git-add

# select branch
function peco-select-from-git-branch() {
  git branch --all --verbose | \
    peco | \
    sed -e 's/\* //g' | \
    awk '{print $1}'  | \
    rev | cut -f1 -d'/' | rev | \
    perl -pe 's/\n/ /g'

}

# select branch and insert it as current input
function peco-insert-branch() {
    LBUFFER+=$(peco-select-from-git-branch)
    CURSOR=$#LBUFFER
    zle reset-prompt
}
zle -N peco-insert-branch
bindkey "^g^o" peco-insert-branch

# select branch to checkout
function peco-select-git-checkout() {
    local SELECTED_FILE_TO_CHECKOUT=`peco-select-from-git-branch`
    if [ -n "$SELECTED_FILE_TO_CHECKOUT" ]; then
      BUFFER="git checkout $(echo "$SELECTED_FILE_TO_CHECKOUT" | tr '\n' ' ')"
      CURSOR=$#BUFFER
    fi
    zle accept-line
}
zle -N peco-select-git-checkout
bindkey "^gco" peco-select-git-checkout

# select file to show git diff which has changed from HEAD
function peco-select-gitdiff() {
    local SELECTED_FILE_TO_DIFF="$(git status --short | \
                                  peco --query "$LBUFFER" | \
                                  awk -F ' ' '{print $NF}')"
    if [ -n "$SELECTED_FILE_TO_DIFF" ]; then
      BUFFER="git diff $(echo "$SELECTED_FILE_TO_DIFF" | tr '\n' ' ')"
      CURSOR=$#BUFFER
    fi
    zle accept-line
    # zle clear-screen
}
zle -N peco-select-gitdiff
bindkey "^g^i" peco-select-gitdiff

# select file from git status view
function peco_select_from_git_status(){
    git status --porcelain | \
      peco | \
      awk -F ' ' '{print $NF}' | \
      tr '\n' ' '
}

# select file from git status view and insert it as current input
function peco_insert_selected_git_files(){
    LBUFFER+=$(peco_select_from_git_status)
    CURSOR=$#LBUFFER
    zle reset-prompt
}
zle -N peco_insert_selected_git_files
bindkey "^g^s" peco_insert_selected_git_files

##########################################
# GCP commands(gcloud) using peco
##########################################

# return true if provided file created at in 1day
function is_too_old() {
  local FILE=$1
  local COMPARISON=$2 # seconds
  if [ -f $FILE ]; then
    [ $(( $(date +%s) - $(stat -c %Y "$1") )) -gt $COMPARISON ]
  else
    return false
  fi
}

# cache
function read-from-cache() {
  local CACHE=$1
  local COMPARISON=$2  # seconds
  local COMMAND=$3
  if $(is_too_old $CACHE $COMPARISON);then
    local result=$(sh -c "$COMMAND")
    if [ -z $result ]; then
      return
    else
      echo $result > $CACHE
    fi
  fi
  cat $CACHE
}

# show active GCP acount
function gcloud-active-acount() {
  gcloud auth list --filter=status:ACTIVE --format="value(account)"
}

# configurating active GCP account
function gcloud-set-acount() {
  local selected=$(gcloud auth list --format="value(account)" | peco)
  echo "Account =>" . $selected
  gcloud config set account $selected
}

# select GCP project from active acount
function gcloud-select-project() {
  local account=$(gcloud-active-acount)
  local PROJECT_CACHE="/var/tmp/gcloud-$account-project.txt"
  local result=$(read-from-cache $PROJECT_CACHE $((60 * 60 * 24)) "gcloud projects list")
  echo $result | peco | awk '{print $1}'
}

# configurating active GCP project
function gcloud-set-project() {
  local proj=$(gcloud-select-project)
  if [ -z $proj ]; then
    return;
  fi
  echo "project set to $proj"
  LBUFFER="gcloud config set project ${proj}"
  zle accept-line
}
zle -N gcloud-set-project
bindkey "^gcp" gcloud-set-project

# select GCP instance with selecting project from active account
function gcloud-compute-instance() {
  local account=$(gcloud-active-acount)
  local project=$(gcloud-select-project)
  local INSTANCE_CACHE="/var/tmp/gcloud-$account-$project-instance.txt"
  if [ -z $project ]; then
    return;
  fi
  local vm_data_raw=$(read-from-cache $INSTANCE_CACHE $((60 * 10)) "gcloud compute instances list --project $project")
  if [ -z $vm_data_raw ]; then
    return;
  fi
  local vm_data=$(echo $vm_data_raw | peco)

  local instance_name=$(echo ${vm_data} | awk '{print $1}')
  local zone_name=$(echo ${vm_data} | awk '{print $2}')
  if [ -n "${instance_name}" ] && [ -n "${zone_name}" ]; then
    echo "--project ${project} --zone ${zone_name} ${instance_name}"
  else
    return false
  fi
}

# select GCP instance information and insert it as current input
function gcloud-compute-instance-edit() {
  LBUFFER="gcloud compute  $(gcloud-compute-instance)"
  CURSOR=15 # move cursor next to `compute `
}
zle -N gcloud-compute-instance-edit
bindkey "^gcl" gcloud-compute-instance-edit

# select GCP instance and ssh
function gcloud-ssh() {
  LBUFFER="gcloud compute ssh $(gcloud-compute-instance)"
  zle accept-line
}
zle -N gcloud-ssh
bindkey "^gcs" gcloud-ssh

###################################

setopt extended_glob

typeset -A abbreviations
abbreviations=(
"G"    "| ag"
"L"    "| less"
"P"    "| pbcopy"
"X"    "| xargs"
"T"    "| tail"
"C"    "| cat"
"W"    "| wc"
"A"    "| awk"
"S"    "| sed"
"E"    "2>&1 > /dev/null"
"N"    "> /dev/null"
"J"    "| jq ."
"v"    "vim"
"gs"   "git status"
"gco"  "git commit -m"
"gl"   "git log"
"jvm"  "-jvm-debug 5005"
)

magic-abbrev-expand() {
  local MATCH
  LBUFFER=${LBUFFER%%(#m)[-_a-zA-Z0-9]#}
  LBUFFER+=${abbreviations[$MATCH]:-$MATCH}
  zle self-insert
}

no-magic-abbrev-expand() {
  LBUFFER+=' '
}

zle -N magic-abbrev-expand
zle -N no-magic-abbrev-expand
bindkey " " magic-abbrev-expand
bindkey "^x " no-magic-abbrev-expand

